<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>可愛守宮老虎機遊戲 - PixiJS 版本</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.3.2/pixi.min.js"></script>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        body {
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #a8e6cf 0%, #dcedc1 50%, #ffd3b6 100%);
            font-family: 'Comic Sans MS', Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }
        h1 {
            color: #2c5f2d;
            text-shadow: 2px 2px 4px rgba(255,255,255,0.5);
            margin-bottom: 20px;
            font-size: 2.5em;
        }
        .game-container {
            background: rgba(255, 255, 255, 0.2);
            padding: 30px;
            border-radius: 25px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            backdrop-filter: blur(10px);
            max-width: 1200px;
        }
        .info-panel {
            display: flex;
            justify-content: space-around;
            margin-bottom: 20px;
            gap: 15px;
            flex-wrap: wrap;
        }
        .info-box {
            background: rgba(255, 255, 255, 0.8);
            padding: 15px 25px;
            border-radius: 15px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            text-align: center;
            min-width: 140px;
        }
        .info-label {
            font-size: 0.9em;
            color: #666;
            margin-bottom: 5px;
        }
        .info-value {
            font-size: 1.5em;
            font-weight: bold;
            color: #2c5f2d;
        }
        #game-canvas {
            display: block;
            margin: 0 auto 20px;
            border-radius: 15px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }
        .controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        .bet-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            background: rgba(255, 255, 255, 0.8);
            padding: 15px 25px;
            border-radius: 15px;
        }
        .bet-controls label {
            font-weight: bold;
            color: #2c5f2d;
        }
        .bet-controls input {
            width: 80px;
            padding: 8px;
            border: 2px solid #2c5f2d;
            border-radius: 8px;
            font-size: 1em;
            text-align: center;
        }
        .btn {
            padding: 15px 40px;
            font-size: 1.2em;
            font-weight: bold;
            border: none;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            font-family: 'Comic Sans MS', Arial, sans-serif;
        }
        .btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }
        .btn:active:not(:disabled) {
            transform: translateY(0);
        }
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .btn-spin {
            background: linear-gradient(135deg, #66bb6a 0%, #43a047 100%);
            color: white;
        }
        .btn-auto {
            background: linear-gradient(135deg, #42a5f5 0%, #1e88e5 100%);
            color: white;
        }
        .btn-stop {
            background: linear-gradient(135deg, #ef5350 0%, #e53935 100%);
            color: white;
        }
        .message {
            text-align: center;
            font-size: 1.3em;
            font-weight: bold;
            padding: 15px;
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.8);
            margin-bottom: 15px;
            min-height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .message.win {
            background: linear-gradient(135deg, #ffd54f 0%, #ffb300 100%);
            color: #5d4037;
            animation: winPulse 0.5s ease-in-out infinite;
        }
        @keyframes winPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.03); }
        }
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        .stat-item {
            background: rgba(255, 255, 255, 0.7);
            padding: 12px;
            border-radius: 10px;
            text-align: center;
        }
        .stat-label {
            font-size: 0.9em;
            color: #666;
        }
        .stat-value {
            font-size: 1.2em;
            font-weight: bold;
            color: #2c5f2d;
            margin-top: 5px;
        }
    </style>
</head>
<body>
    <h1>🦎 可愛守宮老虎機 - PixiJS 版 🎰</h1>
    
    <div class="game-container">
        <div class="info-panel">
            <div class="info-box">
                <div class="info-label">餘額</div>
                <div class="info-value" id="balance">1000</div>
            </div>
            <div class="info-box">
                <div class="info-label">下注金額</div>
                <div class="info-value" id="current-bet">10</div>
            </div>
            <div class="info-box">
                <div class="info-label">本次獲勝</div>
                <div class="info-value" id="win-amount">0</div>
            </div>
        </div>

        <div class="message" id="message">準備開始遊戲！</div>

        <div id="game-canvas"></div>

        <div class="controls">
            <div class="bet-controls">
                <label>下注:</label>
                <input type="number" id="bet-input" min="1" max="100" value="10" step="1">
            </div>
            <button class="btn btn-spin" id="spin-btn">旋轉 🎰</button>
            <button class="btn btn-auto" id="auto-btn">自動旋轉</button>
            <button class="btn btn-stop" id="stop-btn" style="display:none;">停止自動</button>
        </div>

        <div class="stats">
            <div class="stat-item">
                <div class="stat-label">總旋轉次數</div>
                <div class="stat-value" id="total-spins">0</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">總下注金額</div>
                <div class="stat-value" id="total-wagered">0</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">總贏得金額</div>
                <div class="stat-value" id="total-won">0</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">實際 RTP</div>
                <div class="stat-value" id="actual-rtp">--%</div>
            </div>
        </div>
    </div>

    <script>
        // ==================== 遊戲配置 ====================
        const CONFIG = {
            width: 800,
            height: 500,
            reelWidth: 130,
            reelHeight: 390,
            symbolSize: 120,
            symbolGap: 10,
            cols: 5,
            rows: 3,
            symbolsPerReel: 15,
            targetRTP: 0.985
        };

        // ==================== 符號定義 ====================
        const SYMBOLS = {
            GREEN: { key: 'green', name: '綠色守宮', weight: 7, color: 0x7cb342 },
            LEOPARD: { key: 'leopard', name: '豹紋守宮', weight: 6, color: 0xffd54f },
            BLUE: { key: 'blue', name: '藍色守宮', weight: 6, color: 0x42a5f5 },
            PINK: { key: 'pink', name: '粉紅守宮', weight: 5, color: 0xf48fb1 },
            RAINBOW: { key: 'rainbow', name: '彩虹守宮', weight: 1, color: 0xff6b9d, isWild: true },
            ORANGE: { key: 'orange', name: '橘色守宮', weight: 4, color: 0xff9800 },
            PURPLE: { key: 'purple', name: '紫色守宮', weight: 3, color: 0xab47bc },
            BABY: { key: 'baby', name: '守宮寶寶', weight: 2, color: 0xffeb3b, isScatter: true },
            SLEEPING: { key: 'sleeping', name: '睡覺守宮', weight: 9, color: 0x8d6e63 }
        };

        // 賠率表
        const PAYTABLE = {
            rainbow: { 3: 100, 4: 500, 5: 2000 },
            baby: { 3: 50, 4: 200, 5: 500 },
            pink: { 3: 30, 4: 100, 5: 300 },
            purple: { 3: 25, 4: 80, 5: 200 },
            orange: { 3: 20, 4: 60, 5: 150 },
            blue: { 3: 15, 4: 40, 5: 100 },
            leopard: { 3: 15, 4: 40, 5: 100 },
            green: { 3: 10, 4: 30, 5: 80 },
            sleeping: { 3: 5, 4: 15, 5: 40 }
        };

        // 20 條賠付線
        const PAYLINES = [
            [[1,0],[1,1],[1,2],[1,3],[1,4]], // 中線
            [[0,0],[0,1],[0,2],[0,3],[0,4]], // 上線
            [[2,0],[2,1],[2,2],[2,3],[2,4]], // 下線
            [[0,0],[1,1],[2,2],[1,3],[0,4]], // V形
            [[2,0],[1,1],[0,2],[1,3],[2,4]], // 倒V形
            [[1,0],[0,1],[0,2],[0,3],[1,4]], // W上
            [[1,0],[2,1],[2,2],[2,3],[1,4]], // W下
            [[0,0],[0,1],[1,2],[2,3],[2,4]], // 斜下
            [[2,0],[2,1],[1,2],[0,3],[0,4]], // 斜上
            [[1,0],[2,1],[1,2],[0,3],[1,4]], // M形
            [[1,0],[0,1],[1,2],[2,3],[1,4]], // W形
            [[0,0],[1,1],[1,2],[1,3],[0,4]], // 箭頭上
            [[2,0],[1,1],[1,2],[1,3],[2,4]], // 箭頭下
            [[0,0],[2,1],[0,2],[2,3],[0,4]], // Z形1
            [[2,0],[0,1],[2,2],[0,3],[2,4]], // Z形2
            [[1,0],[1,1],[0,2],[1,3],[1,4]], // 上凸
            [[1,0],[1,1],[2,2],[1,3],[1,4]], // 下凹
            [[0,0],[1,1],[2,2],[2,3],[2,4]], // 斜下寬
            [[2,0],[1,1],[0,2],[0,3],[0,4]], // 斜上寬
            [[1,0],[2,1],[2,2],[1,3],[0,4]]  // 對角線
        ];

        // ==================== 遊戲狀態 ====================
        const gameState = {
            balance: 1000,
            bet: 10,
            winAmount: 0,
            totalSpins: 0,
            totalWagered: 0,
            totalWon: 0,
            isSpinning: false,
            isAutoSpin: false,
            reels: []
        };

        // ==================== PixiJS 初始化 ====================
        const app = new PIXI.Application({
            width: CONFIG.width,
            height: CONFIG.height,
            backgroundColor: 0x8b4513,
            antialias: true
        });
        document.getElementById('game-canvas').appendChild(app.view);

        // 創建容器
        const mainContainer = new PIXI.Container();
        app.stage.addChild(mainContainer);

        // 背景特效容器
        const effectsContainer = new PIXI.Container();
        mainContainer.addChild(effectsContainer);

        // 輪軸容器
        const reelsContainer = new PIXI.Container();
        reelsContainer.x = 50;
        reelsContainer.y = 55;
        mainContainer.addChild(reelsContainer);

        // 創建背景
        const bgGraphics = new PIXI.Graphics();
        bgGraphics.beginFill(0x8b4513);
        bgGraphics.drawRoundedRect(0, 0, CONFIG.width, CONFIG.height, 15);
        bgGraphics.endFill();
        mainContainer.addChildAt(bgGraphics, 0);

        // 創建輪軸背景
        const reelBg = new PIXI.Graphics();
        reelBg.beginFill(0x000000, 0.3);
        reelBg.drawRoundedRect(30, 35, CONFIG.reelWidth * 5 + 40, CONFIG.reelHeight + 40, 15);
        reelBg.endFill();
        mainContainer.addChildAt(reelBg, 1);

        // ==================== 背景特效 ====================
        let effectsActive = false;
        const particles = [];

        function createBackgroundEffects() {
            // 清空舊特效
            effectsContainer.removeChildren();
            particles.length = 0;

            // 光暈效果
            const glow = new PIXI.Graphics();
            glow.beginFill(0xffd700, 0.3);
            glow.drawCircle(CONFIG.width / 2, CONFIG.height / 2, 150);
            glow.endFill();
            effectsContainer.addChild(glow);

            // 漸變背景
            const gradientBg = new PIXI.Graphics();
            gradientBg.beginFill(0xffd700, 0.1);
            gradientBg.drawRect(0, 0, CONFIG.width, CONFIG.height);
            gradientBg.endFill();
            effectsContainer.addChild(gradientBg);

            // 粒子效果
            for (let i = 0; i < 30; i++) {
                const particle = new PIXI.Graphics();
                particle.beginFill(0xffffff);
                particle.drawCircle(0, 0, 2 + Math.random() * 2);
                particle.endFill();
                particle.x = Math.random() * CONFIG.width;
                particle.y = Math.random() * CONFIG.height;
                particle.velocity = 1 + Math.random() * 2;
                particle.alpha = 0.5 + Math.random() * 0.5;
                effectsContainer.addChild(particle);
                particles.push(particle);
            }

            effectsContainer.alpha = 0;
        }

        function updateEffects(delta) {
            if (!effectsActive) return;

            // 更新粒子
            particles.forEach(particle => {
                particle.y -= particle.velocity;
                if (particle.y < 0) {
                    particle.y = CONFIG.height;
                    particle.x = Math.random() * CONFIG.width;
                }
            });

            // 光暈脈動
            const glow = effectsContainer.children[0];
            if (glow) {
                glow.alpha = 0.3 + Math.sin(Date.now() / 500) * 0.2;
                glow.scale.set(1 + Math.sin(Date.now() / 1000) * 0.1);
            }
        }

        function showEffects() {
            effectsActive = true;
            gsap.to(effectsContainer, { alpha: 1, duration: 0.5 });
        }

        function hideEffects() {
            effectsActive = false;
            gsap.to(effectsContainer, { alpha: 0, duration: 0.5 });
        }

        createBackgroundEffects();

        // ==================== 符號繪製函數 ====================
        function createSymbolTexture(symbolKey) {
            const canvas = document.createElement('canvas');
            canvas.width = CONFIG.symbolSize;
            canvas.height = CONFIG.symbolSize;
            const ctx = canvas.getContext('2d');

            // 背景
            ctx.fillStyle = '#fff9e6';
            ctx.beginPath();
            ctx.roundRect(2, 2, CONFIG.symbolSize - 4, CONFIG.symbolSize - 4, 12);
            ctx.fill();

            ctx.save();
            ctx.scale(0.75, 0.75);
            ctx.translate(80, 80);

            switch(symbolKey) {
                case 'green':
                    drawGreenGeckoCloseup(ctx);
                    break;
                case 'leopard':
                    drawLeopardGecko(ctx);
                    break;
                case 'blue':
                    drawBlueGeckoCloseup(ctx);
                    break;
                case 'pink':
                    drawPinkGeckoCloseup(ctx);
                    break;
                case 'rainbow':
                    drawRainbowGeckoCloseup(ctx);
                    break;
                case 'orange':
                    drawOrangeGeckoCloseup(ctx);
                    break;
                case 'purple':
                    drawPurpleGeckoCloseup(ctx);
                    break;
                case 'baby':
                    drawBabyGecko(ctx);
                    break;
                case 'sleeping':
                    drawSleepingGecko(ctx);
                    break;
            }

            ctx.restore();

            return PIXI.Texture.from(canvas);
        }

        // 綠色守宮特寫
        function drawGreenGeckoCloseup(ctx) {
            // 頭部
            ctx.fillStyle = '#7cb342';
            ctx.beginPath();
            ctx.ellipse(0, -5, 50, 48, 0, 0, Math.PI * 2);
            ctx.fill();

            // 眼睛
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.ellipse(-15, -10, 18, 22, -0.1, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#558b2f';
            ctx.lineWidth = 2;
            ctx.stroke();

            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.ellipse(15, -10, 18, 22, 0.1, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();

            // 瞳孔
            ctx.fillStyle = '#2c3e50';
            ctx.beginPath();
            ctx.ellipse(-13, -8, 10, 14, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(13, -8, 10, 14, 0, 0, Math.PI * 2);
            ctx.fill();

            // 高光
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.arc(-15, -12, 6, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(11, -12, 6, 0, Math.PI * 2);
            ctx.fill();

            // 鼻子
            ctx.fillStyle = '#558b2f';
            ctx.beginPath();
            ctx.ellipse(0, 5, 6, 4, 0, 0, Math.PI * 2);
            ctx.fill();

            // 微笑
            ctx.strokeStyle = '#558b2f';
            ctx.lineWidth = 2.5;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.arc(0, 12, 15, 0.2, Math.PI - 0.2);
            ctx.stroke();

            // 腮紅
            ctx.fillStyle = 'rgba(255, 182, 193, 0.5)';
            ctx.beginPath();
            ctx.ellipse(-28, 0, 8, 6, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(28, 0, 8, 6, 0, 0, Math.PI * 2);
            ctx.fill();
        }

        // 藍色守宮特寫
        function drawBlueGeckoCloseup(ctx) {
            ctx.fillStyle = '#42a5f5';
            ctx.beginPath();
            ctx.ellipse(0, 0, 52, 50, 0, 0, Math.PI * 2);
            ctx.fill();

            // 大眼睛
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.ellipse(-18, -5, 20, 24, -0.1, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#1565c0';
            ctx.lineWidth = 3;
            ctx.stroke();

            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.ellipse(18, -5, 20, 24, 0.1, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();

            // 瞳孔
            ctx.fillStyle = '#0d47a1';
            ctx.beginPath();
            ctx.ellipse(-16, -2, 11, 16, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(16, -2, 11, 16, 0, 0, Math.PI * 2);
            ctx.fill();

            // 高光
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.beginPath();
            ctx.ellipse(-19, -8, 8, 10, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(15, -8, 8, 10, 0, 0, Math.PI * 2);
            ctx.fill();

            // O形嘴巴
            ctx.strokeStyle = '#1565c0';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(0, 12, 6, 0, Math.PI * 2);
            ctx.stroke();

            ctx.fillStyle = 'rgba(255, 192, 203, 0.6)';
            ctx.beginPath();
            ctx.arc(0, 12, 4, 0, Math.PI * 2);
            ctx.fill();

            // 腮紅
            ctx.fillStyle = 'rgba(144, 202, 249, 0.6)';
            ctx.beginPath();
            ctx.ellipse(-32, 5, 10, 7, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(32, 5, 10, 7, 0, 0, Math.PI * 2);
            ctx.fill();
        }

        // 粉紅守宮特寫
        function drawPinkGeckoCloseup(ctx) {
            ctx.fillStyle = '#f48fb1';
            ctx.beginPath();
            ctx.ellipse(0, -2, 48, 46, 0, 0, Math.PI * 2);
            ctx.fill();

            // 閉眼
            ctx.strokeStyle = '#ec407a';
            ctx.lineWidth = 3;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.arc(-17, -5, 12, 0.3, Math.PI - 0.3);
            ctx.stroke();

            ctx.beginPath();
            ctx.arc(17, -5, 12, 0.3, Math.PI - 0.3);
            ctx.stroke();

            // 眉毛
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(-17, -10, 8, Math.PI + 0.5, Math.PI * 2 - 0.5);
            ctx.stroke();
            ctx.beginPath();
            ctx.arc(17, -10, 8, Math.PI + 0.5, Math.PI * 2 - 0.5);
            ctx.stroke();

            // 微笑
            ctx.lineWidth = 2.5;
            ctx.beginPath();
            ctx.arc(0, 8, 12, 0.2, Math.PI - 0.2);
            ctx.stroke();

            // 大腮紅
            ctx.fillStyle = 'rgba(255, 105, 180, 0.6)';
            ctx.beginPath();
            ctx.ellipse(-28, 2, 10, 8, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(28, 2, 10, 8, 0, 0, Math.PI * 2);
            ctx.fill();
        }

        // 彩虹守宮特寫
        function drawRainbowGeckoCloseup(ctx) {
            // 彩虹頭部
            const gradient = ctx.createLinearGradient(-50, -50, 50, 50);
            gradient.addColorStop(0, '#ff6b6b');
            gradient.addColorStop(0.25, '#ffd93d');
            gradient.addColorStop(0.5, '#6bcf7f');
            gradient.addColorStop(0.75, '#4d96ff');
            gradient.addColorStop(1, '#9b59b6');
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.ellipse(0, 0, 50, 48, 0, 0, Math.PI * 2);
            ctx.fill();

            // 金框
            ctx.strokeStyle = '#ffd700';
            ctx.lineWidth = 3;
            ctx.stroke();

            // 大眼睛
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.ellipse(-17, -4, 19, 23, -0.1, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();

            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.ellipse(17, -4, 19, 23, 0.1, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();

            // 瞳孔
            ctx.fillStyle = '#2c3e50';
            ctx.beginPath();
            ctx.ellipse(-15, -2, 10, 15, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(15, -2, 10, 15, 0, 0, Math.PI * 2);
            ctx.fill();

            // 彩虹高光
            ctx.fillStyle = 'rgba(255, 255, 255, 1)';
            ctx.beginPath();
            ctx.arc(-17, -7, 7, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(15, -7, 7, 0, Math.PI * 2);
            ctx.fill();

            // WILD文字
            ctx.font = 'bold 12px Arial';
            ctx.fillStyle = '#ffd700';
            ctx.strokeStyle = '#8b4513';
            ctx.lineWidth = 2;
            ctx.textAlign = 'center';
            ctx.strokeText('WILD', 0, 30);
            ctx.fillText('WILD', 0, 30);
        }

        // 橘色守宮特寫
        function drawOrangeGeckoCloseup(ctx) {
            ctx.fillStyle = '#ff9800';
            ctx.beginPath();
            ctx.ellipse(0, 0, 50, 47, 0, 0, Math.PI * 2);
            ctx.fill();

            // 燃燒眼睛
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.ellipse(-17, -5, 18, 22, -0.1, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#ff6f00';
            ctx.lineWidth = 3;
            ctx.stroke();

            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.ellipse(17, -5, 18, 22, 0.1, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();

            // 瞳孔漸層
            const pupilGradient = ctx.createRadialGradient(-15, -3, 2, -15, -3, 12);
            pupilGradient.addColorStop(0, '#000000');
            pupilGradient.addColorStop(0.7, '#bf360c');
            pupilGradient.addColorStop(1, '#ff6f00');
            ctx.fillStyle = pupilGradient;
            ctx.beginPath();
            ctx.ellipse(-15, -3, 11, 15, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(15, -3, 11, 15, 0, 0, Math.PI * 2);
            ctx.fill();

            // 高光
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.beginPath();
            ctx.ellipse(-18, -8, 7, 9, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(14, -8, 7, 9, 0, 0, Math.PI * 2);
            ctx.fill();

            // 微笑
            ctx.strokeStyle = '#e65100';
            ctx.lineWidth = 2.5;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.arc(0, 8, 14, 0.2, Math.PI - 0.2);
            ctx.stroke();

            // 腮紅
            ctx.fillStyle = 'rgba(255, 152, 0, 0.5)';
            ctx.beginPath();
            ctx.ellipse(-30, 3, 9, 7, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(30, 3, 9, 7, 0, 0, Math.PI * 2);
            ctx.fill();
        }

        // 紫色守宮特寫
        function drawPurpleGeckoCloseup(ctx) {
            ctx.fillStyle = '#ab47bc';
            ctx.beginPath();
            ctx.ellipse(0, -2, 49, 46, 0, 0, Math.PI * 2);
            ctx.fill();

            // 星空眼睛
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.ellipse(-17, -5, 19, 23, -0.1, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#6a1b9a';
            ctx.lineWidth = 3;
            ctx.stroke();

            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.ellipse(17, -5, 19, 23, 0.1, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();

            // 瞳孔
            ctx.fillStyle = '#4a148c';
            ctx.beginPath();
            ctx.ellipse(-15, -2, 10, 14, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(15, -2, 10, 14, 0, 0, Math.PI * 2);
            ctx.fill();

            // 高光
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.beginPath();
            ctx.arc(-18, -6, 6, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(15, -6, 6, 0, Math.PI * 2);
            ctx.fill();

            // 微笑
            ctx.strokeStyle = '#6a1b9a';
            ctx.lineWidth = 2.5;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.arc(0, 8, 13, 0.2, Math.PI - 0.2);
            ctx.stroke();

            // 腮紅
            ctx.fillStyle = 'rgba(186, 104, 200, 0.5)';
            ctx.beginPath();
            ctx.ellipse(-30, 4, 9, 7, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(30, 4, 9, 7, 0, 0, Math.PI * 2);
            ctx.fill();
        }

        // 豹紋守宮 (全身)
        function drawLeopardGecko(ctx) {
            drawGeckoBase(ctx, '#ffd54f', '#8d6e63', { x: 0, y: 0, scale: 1 });
        }

        // 守宮寶寶
        function drawBabyGecko(ctx) {
            // 蛋殼
            ctx.fillStyle = '#f5f5dc';
            ctx.strokeStyle = '#d2b48c';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.ellipse(0, 30, 35, 30, 0, 0, Math.PI);
            ctx.fill();
            ctx.stroke();

            // 小守宮
            drawGeckoBase(ctx, '#ffeb3b', '#fbc02d', { x: 0, y: 10, scale: 0.5 });

            // SCATTER
            ctx.font = 'bold 10px Arial';
            ctx.fillStyle = '#f57c00';
            ctx.textAlign = 'center';
            ctx.fillText('SCATTER', 0, 50);
        }

        // 睡覺守宮
        function drawSleepingGecko(ctx) {
            ctx.save();
            ctx.rotate(-Math.PI / 6);
            drawGeckoBase(ctx, '#8d6e63', '#5d4037', { x: 0, y: 0, scale: 0.9, expression: 'sleeping' });
            ctx.restore();

            // ZZZ
            ctx.font = 'bold 14px Arial';
            ctx.fillStyle = '#5d4037';
            ctx.textAlign = 'center';
            ctx.fillText('Z', 20, -20);
            ctx.font = 'bold 12px Arial';
            ctx.fillText('Z', 28, -28);
            ctx.font = 'bold 10px Arial';
            ctx.fillText('Z', 34, -34);
        }

        // 基礎守宮繪製
        function drawGeckoBase(ctx, bodyColor, spotColor, options = {}) {
            const { x = 0, y = 0, scale = 1, rotation = 0, expression = 'happy' } = options;
            
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(rotation);
            ctx.scale(scale, scale);

            // 尾巴
            ctx.fillStyle = bodyColor;
            ctx.beginPath();
            ctx.moveTo(15, 0);
            for (let i = 0; i <= 10; i++) {
                const t = i / 10;
                const bx = 15 + t * 35;
                const by = Math.sin(t * Math.PI) * 8;
                const width = 8 * (1 - t * 0.7);
                if (i === 0) {
                    ctx.moveTo(bx, by - width);
                } else {
                    ctx.lineTo(bx, by - width);
                }
            }
            for (let i = 10; i >= 0; i--) {
                const t = i / 10;
                const bx = 15 + t * 35;
                const by = Math.sin(t * Math.PI) * 8;
                const width = 8 * (1 - t * 0.7);
                ctx.lineTo(bx, by + width);
            }
            ctx.closePath();
            ctx.fill();

            // 身體
            ctx.beginPath();
            ctx.ellipse(0, 0, 28, 15, 0, 0, Math.PI * 2);
            ctx.fill();

            // 斑點
            ctx.fillStyle = spotColor;
            ctx.globalAlpha = 0.6;
            for (let i = 0; i < 5; i++) {
                const sx = -20 + Math.random() * 60;
                const sy = -8 + Math.random() * 16;
                const size = 2 + Math.random() * 3;
                ctx.beginPath();
                ctx.arc(sx, sy, size, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1.0;

            // 頭部
            ctx.fillStyle = bodyColor;
            ctx.beginPath();
            ctx.ellipse(-28, 0, 16, 14, 0, 0, Math.PI * 2);
            ctx.fill();

            // 眼睛
            if (expression === 'sleeping') {
                ctx.strokeStyle = '#2c3e50';
                ctx.lineWidth = 1.5;
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.arc(-33, -3, 4, 0.2, Math.PI - 0.2);
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(-23, -3, 4, 0.2, Math.PI - 0.2);
                ctx.stroke();
            } else {
                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.arc(-33, -2, 5, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(-23, -2, 5, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = '#2c3e50';
                ctx.beginPath();
                ctx.arc(-32, -1, 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(-24, -1, 3, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.arc(-31, -2, 1.5, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(-23, -2, 1.5, 0, Math.PI * 2);
                ctx.fill();
            }

            // 微笑
            if (expression === 'happy') {
                ctx.strokeStyle = '#2c3e50';
                ctx.lineWidth = 1.5;
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.arc(-28, 3, 4, 0.1, Math.PI - 0.1);
                ctx.stroke();
            }

            // 腳
            ctx.fillStyle = bodyColor;
            [-18, -8, 8, 18].forEach((xPos, idx) => {
                ctx.beginPath();
                ctx.ellipse(xPos, idx < 2 ? 12 : 12, 4, 8, idx % 2 ? 0.3 : -0.3, 0, Math.PI * 2);
                ctx.fill();
            });

            ctx.restore();
        }

        // ==================== 輪軸系統 ====================
        class Reel {
            constructor(index) {
                this.index = index;
                this.container = new PIXI.Container();
                this.container.x = index * (CONFIG.reelWidth + CONFIG.symbolGap);
                
                // 創建遮罩
                const mask = new PIXI.Graphics();
                mask.beginFill(0xffffff);
                mask.drawRect(0, 0, CONFIG.reelWidth, CONFIG.reelHeight);
                mask.endFill();
                this.container.mask = mask;
                this.container.addChild(mask);
                
                // 符號容器
                this.symbolContainer = new PIXI.Container();
                this.container.addChild(this.symbolContainer);
                
                this.symbols = [];
                this.isSpinning = false;
                this.position = 0;
                this.targetPosition = 0;
                
                this.initSymbols();
                reelsContainer.addChild(this.container);
            }

            initSymbols() {
                this.symbols = [];
                const symbolKeys = Object.keys(SYMBOLS);
                
                for (let i = 0; i < CONFIG.symbolsPerReel; i++) {
                    const randomKey = symbolKeys[Math.floor(Math.random() * symbolKeys.length)];
                    const texture = createSymbolTexture(SYMBOLS[randomKey].key);
                    const sprite = new PIXI.Sprite(texture);
                    
                    sprite.width = CONFIG.symbolSize;
                    sprite.height = CONFIG.symbolSize;
                    sprite.y = i * (CONFIG.symbolSize + CONFIG.symbolGap);
                    sprite.symbolKey = SYMBOLS[randomKey].key;
                    
                    this.symbols.push(sprite);
                    this.symbolContainer.addChild(sprite);
                }
                
                // 設置初始位置顯示中間 3 個
                this.symbolContainer.y = -(CONFIG.symbolSize + CONFIG.symbolGap) * 6;
            }

            getWeightedRandomSymbol() {
                const totalWeight = Object.values(SYMBOLS).reduce((sum, s) => sum + s.weight, 0);
                let random = Math.random() * totalWeight;
                
                for (const symbol of Object.values(SYMBOLS)) {
                    random -= symbol.weight;
                    if (random <= 0) return symbol.key;
                }
                return 'sleeping';
            }

            async spin(finalSymbols) {
                this.isSpinning = true;
                
                // 更新符號為最終結果
                const visibleIndices = [6, 7, 8];
                visibleIndices.forEach((idx, i) => {
                    const sprite = this.symbols[idx];
                    sprite.symbolKey = finalSymbols[i];
                    sprite.texture = createSymbolTexture(finalSymbols[i]);
                });
                
                // 加速階段
                await this.accelerate();
                
                // 全速旋轉
                await this.fullSpeedSpin();
                
                // 減速停止
                await this.decelerate();
                
                this.isSpinning = false;
            }

            async accelerate() {
                return new Promise(resolve => {
                    const duration = 300;
                    const startY = this.symbolContainer.y;
                    const distance = CONFIG.symbolSize * 3;
                    const startTime = Date.now();
                    
                    const animate = () => {
                        const elapsed = Date.now() - startTime;
                        const progress = Math.min(elapsed / duration, 1);
                        const eased = this.easeIn(progress);
                        
                        this.symbolContainer.y = startY - distance * eased;
                        
                        // 循環符號
                        this.wrapSymbols();
                        
                        if (progress < 1) {
                            requestAnimationFrame(animate);
                        } else {
                            resolve();
                        }
                    };
                    
                    animate();
                });
            }

            async fullSpeedSpin() {
                return new Promise(resolve => {
                    const duration = 1500;
                    const startTime = Date.now();
                    
                    const animate = () => {
                        const elapsed = Date.now() - startTime;
                        
                        this.symbolContainer.y -= 15;
                        this.wrapSymbols();
                        
                        if (elapsed < duration) {
                            requestAnimationFrame(animate);
                        } else {
                            resolve();
                        }
                    };
                    
                    animate();
                });
            }

            async decelerate() {
                return new Promise(resolve => {
                    const targetY = -(CONFIG.symbolSize + CONFIG.symbolGap) * 6;
                    const duration = 400;
                    const startY = this.symbolContainer.y;
                    const startTime = Date.now();
                    
                    const animate = () => {
                        const elapsed = Date.now() - startTime;
                        const progress = Math.min(elapsed / duration, 1);
                        const eased = this.easeOut(progress);
                        
                        this.symbolContainer.y = startY + (targetY - startY) * eased;
                        
                        if (progress < 1) {
                            requestAnimationFrame(animate);
                        } else {
                            this.symbolContainer.y = targetY;
                            this.bounce().then(resolve);
                        }
                    };
                    
                    animate();
                });
            }

            async bounce() {
                const baseY = -(CONFIG.symbolSize + CONFIG.symbolGap) * 6;
                
                return new Promise(resolve => {
                    // 過頭
                    gsap.to(this.symbolContainer, {
                        y: baseY + 22,
                        duration: 0.18,
                        ease: "power2.out",
                        onComplete: () => {
                            // 回彈1
                            gsap.to(this.symbolContainer, {
                                y: baseY - 15,
                                duration: 0.14,
                                ease: "back.out(2.5)",
                                onComplete: () => {
                                    // 下落2
                                    gsap.to(this.symbolContainer, {
                                        y: baseY + 6,
                                        duration: 0.12,
                                        ease: "power1.in",
                                        onComplete: () => {
                                            // 回彈2
                                            gsap.to(this.symbolContainer, {
                                                y: baseY - 4,
                                                duration: 0.1,
                                                ease: "back.out(2.0)",
                                                onComplete: () => {
                                                    // 穩定
                                                    gsap.to(this.symbolContainer, {
                                                        y: baseY,
                                                        duration: 0.08,
                                                        ease: "power1.out",
                                                        onComplete: resolve
                                                    });
                                                }
                                            });
                                        }
                                    });
                                }
                            });
                        }
                    });
                });
            }

            wrapSymbols() {
                const containerY = this.symbolContainer.y;
                const symbolHeight = CONFIG.symbolSize + CONFIG.symbolGap;
                
                this.symbols.forEach(sprite => {
                    const globalY = containerY + sprite.y;
                    
                    if (globalY < -symbolHeight) {
                        sprite.y += symbolHeight * CONFIG.symbolsPerReel;
                    } else if (globalY > CONFIG.reelHeight + symbolHeight) {
                        sprite.y -= symbolHeight * CONFIG.symbolsPerReel;
                    }
                });
            }

            getVisibleSymbols() {
                return [6, 7, 8].map(idx => this.symbols[idx].symbolKey);
            }

            highlightWin(row) {
                const sprite = this.symbols[6 + row];
                gsap.to(sprite.scale, {
                    x: 1.1,
                    y: 1.1,
                    duration: 0.3,
                    yoyo: true,
                    repeat: -1
                });
            }

            clearHighlight() {
                this.symbols.forEach(sprite => {
                    gsap.killTweensOf(sprite.scale);
                    sprite.scale.set(1, 1);
                });
            }

            easeIn(t) {
                return t * t;
            }

            easeOut(t) {
                return t * (2 - t);
            }
        }

        // 創建輪軸
        const reels = [];
        for (let i = 0; i < CONFIG.cols; i++) {
            reels.push(new Reel(i));
        }

        // ==================== 遊戲邏輯 ====================
        function getWeightedRandomSymbol() {
            const totalWeight = Object.values(SYMBOLS).reduce((sum, s) => sum + s.weight, 0);
            let random = Math.random() * totalWeight;
            
            for (const symbol of Object.values(SYMBOLS)) {
                random -= symbol.weight;
                if (random <= 0) return symbol.key;
            }
            return 'sleeping';
        }

        function checkWins() {
            const currentReels = reels.map(reel => reel.getVisibleSymbols());
            const wins = [];

            // 檢查賠付線
            PAYLINES.forEach((line, lineIndex) => {
                const symbols = line.map(([row, col]) => currentReels[col][row]);
                const firstSymbol = symbols[0];
                let matchCount = 1;

                // 計算連續匹配
                for (let i = 1; i < symbols.length; i++) {
                    if (symbols[i] === firstSymbol || symbols[i] === 'rainbow') {
                        matchCount++;
                    } else if (firstSymbol === 'rainbow') {
                        matchCount++;
                    } else {
                        break;
                    }
                }

                // 檢查賠率
                const paySymbol = firstSymbol === 'rainbow' ? symbols.find(s => s !== 'rainbow') || 'rainbow' : firstSymbol;
                if (matchCount >= 3 && PAYTABLE[paySymbol]) {
                    const payout = PAYTABLE[paySymbol][matchCount] || 0;
                    if (payout > 0) {
                        wins.push({
                            line: line.slice(0, matchCount),
                            symbol: paySymbol,
                            count: matchCount,
                            payout: payout
                        });
                    }
                }
            });

            // 檢查 SCATTER
            let scatterCount = 0;
            const scatterPositions = [];
            currentReels.forEach((reelSymbols, col) => {
                reelSymbols.forEach((symbol, row) => {
                    if (symbol === 'baby') {
                        scatterCount++;
                        scatterPositions.push([row, col]);
                    }
                });
            });

            if (scatterCount >= 3 && PAYTABLE.baby[scatterCount]) {
                wins.push({
                    line: scatterPositions,
                    symbol: 'baby',
                    count: scatterCount,
                    payout: PAYTABLE.baby[scatterCount],
                    isScatter: true
                });
            }

            return wins;
        }

        async function spin() {
            if (gameState.isSpinning) return;
            
            const bet = parseInt(document.getElementById('bet-input').value);
            if (bet > gameState.balance) {
                updateMessage('餘額不足！');
                return;
            }

            gameState.isSpinning = true;
            gameState.bet = bet;
            gameState.balance -= bet;
            gameState.totalSpins++;
            gameState.totalWagered += bet;
            
            updateUI();
            updateMessage('旋轉中...');
            
            document.getElementById('spin-btn').disabled = true;
            document.getElementById('auto-btn').disabled = true;
            document.getElementById('bet-input').disabled = true;

            // 啟動特效
            showEffects();

            // 清除高亮
            reels.forEach(reel => reel.clearHighlight());

            // 生成最終結果
            const finalResults = [];
            for (let i = 0; i < 5; i++) {
                const reelResult = [];
                for (let row = 0; row < 3; row++) {
                    reelResult.push(getWeightedRandomSymbol());
                }
                finalResults.push(reelResult);
            }

            // 開始旋轉（波浪式）
            const spinPromises = [];
            for (let i = 0; i < 5; i++) {
                await new Promise(resolve => setTimeout(resolve, 80 * i));
                spinPromises.push(reels[i].spin(finalResults[i]));
            }

            // 等待所有輪軸停止
            await Promise.all(spinPromises);

            // 關閉特效
            hideEffects();

            // 檢查獲勝
            await new Promise(resolve => setTimeout(resolve, 300));
            const wins = checkWins();
            
            let totalWin = 0;
            if (wins.length > 0) {
                wins.forEach(win => {
                    totalWin += win.payout * bet;
                    
                    // 高亮獲勝符號
                    if (win.line) {
                        win.line.forEach(([row, col]) => {
                            reels[col].highlightWin(row);
                        });
                    }
                });

                gameState.balance += totalWin;
                gameState.winAmount = totalWin;
                gameState.totalWon += totalWin;
                
                updateMessage(`🎉 恭喜！贏得 ${totalWin} 元！`, true);
            } else {
                gameState.winAmount = 0;
                updateMessage('祝你下次好運！');
            }

            updateUI();
            
            gameState.isSpinning = false;
            document.getElementById('spin-btn').disabled = false;
            document.getElementById('auto-btn').disabled = false;
            document.getElementById('bet-input').disabled = false;

            // 自動旋轉
            if (gameState.isAutoSpin && gameState.balance >= gameState.bet) {
                setTimeout(() => spin(), 1000);
            } else if (gameState.isAutoSpin) {
                stopAutoSpin();
                updateMessage('餘額不足，自動旋轉已停止');
            }
        }

        function updateUI() {
            document.getElementById('balance').textContent = gameState.balance;
            document.getElementById('current-bet').textContent = gameState.bet;
            document.getElementById('win-amount').textContent = gameState.winAmount;
            document.getElementById('total-spins').textContent = gameState.totalSpins;
            document.getElementById('total-wagered').textContent = gameState.totalWagered;
            document.getElementById('total-won').textContent = gameState.totalWon;
            
            const actualRTP = gameState.totalWagered > 0 
                ? ((gameState.totalWon / gameState.totalWagered) * 100).toFixed(2) 
                : '--';
            document.getElementById('actual-rtp').textContent = actualRTP + '%';
        }

        function updateMessage(text, isWin = false) {
            const msgEl = document.getElementById('message');
            msgEl.textContent = text;
            msgEl.classList.toggle('win', isWin);
        }

        function startAutoSpin() {
            if (gameState.isSpinning) return;
            gameState.isAutoSpin = true;
            document.getElementById('auto-btn').style.display = 'none';
            document.getElementById('stop-btn').style.display = 'inline-block';
            spin();
        }

        function stopAutoSpin() {
            gameState.isAutoSpin = false;
            document.getElementById('auto-btn').style.display = 'inline-block';
            document.getElementById('stop-btn').style.display = 'none';
        }

        // ==================== 事件監聽 ====================
        document.getElementById('spin-btn').addEventListener('click', spin);
        document.getElementById('auto-btn').addEventListener('click', startAutoSpin);
        document.getElementById('stop-btn').addEventListener('click', stopAutoSpin);
        document.getElementById('bet-input').addEventListener('change', (e) => {
            gameState.bet = parseInt(e.target.value);
            updateUI();
        });

        // ==================== 動畫循環 ====================
        app.ticker.add((delta) => {
            updateEffects(delta);
        });

        // 添加 GSAP CDN
        const gsapScript = document.createElement('script');
        gsapScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js';
        document.head.appendChild(gsapScript);

        // 初始化 UI
        updateUI();
    </script>
</body>
</html>