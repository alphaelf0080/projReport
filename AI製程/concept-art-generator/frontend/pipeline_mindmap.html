<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="UTF-8" />
<title>Slot Game AI Pipeline Mind Map</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
:root {
  --bg:#0f1115; --panel:#1c222b; --panel2:#202a35; --border:#2f3a46; --text:#e6e9ef; --dim:#9aa4b1;
  --accent:#4f8bff; --accent-grad:linear-gradient(135deg,#4f8bff,#8855ff 60%,#ff3fa4);
  --ok:#3fbf74; --warn:#f5c451; --danger:#ff5f56; --radius:14px;
}
*{box-sizing:border-box;} html,body{margin:0;padding:0;font-family:'Inter',system-ui,-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,'Helvetica Neue',Arial,sans-serif;background:radial-gradient(circle at 18% 18%,#1c2430,#0f1115 60%);color:var(--text);-webkit-font-smoothing:antialiased;}
body{line-height:1.55;}
header{display:flex;flex-wrap:wrap;align-items:center;gap:1rem;justify-content:space-between;padding:1.2rem 1.6rem;background:rgba(28,34,43,.65);backdrop-filter:blur(14px);border-bottom:1px solid var(--border);}
header h1{font-size:1.15rem;margin:0;background:var(--accent-grad);-webkit-background-clip:text;color:transparent;letter-spacing:.5px;}
nav a{color:var(--dim);text-decoration:none;font-size:.8rem;padding:.45rem .8rem;border:1px solid var(--border);border-radius:40px;transition:.25s;background:var(--panel2);} nav a:hover{color:var(--text);border-color:var(--accent);}

main{padding:1.4rem 1.6rem 4rem;max-width:1500px;margin:0 auto;}
.tools-bar{display:flex;flex-wrap:wrap;gap:.75rem;margin-bottom:1rem;}
.tools-bar input{background:var(--panel2);border:1px solid var(--border);color:var(--text);padding:.55rem .75rem;border-radius:10px;min-width:240px;font-size:.8rem;}
.tools-bar button{background:var(--panel2);border:1px solid var(--border);color:var(--text);padding:.55rem .9rem;border-radius:10px;font-size:.7rem;letter-spacing:.5px;cursor:pointer;transition:.25s;font-weight:600;} .tools-bar button:hover{border-color:var(--accent);color:#fff;}

#mindmap-wrapper{position:relative;overflow:auto;border:1px solid var(--border);border-radius:var(--radius);background:var(--panel);padding:1.2rem;min-height:70vh;}

.tree{--gap-y:1.2rem; --gap-x:1.8rem; font-size:.78rem; line-height:1.35;}
.tree ul{margin:0;padding:0 0 0 1.2rem;list-style:none;position:relative;}
.tree ul:before{content:"";position:absolute;left:.3rem;top:.4rem;bottom:.75rem;width:1px;background:#334252;}
.tree li{margin:0;padding:.35rem .65rem .35rem 1.05rem;position:relative;background:var(--panel2);border:1px solid #2e3945;border-radius:10px;display:inline-block;min-width:140px;max-width:280px;vertical-align:top;box-shadow:0 2px 6px -2px rgba(0,0,0,.4);transition:.25s;}
.tree li + li{margin-left:.6rem;}
.tree li:hover{border-color:#4f8bff;}
.tree li.collapsed > ul{display:none;}
.tree li .toggle{position:absolute;left:.35rem;top:.38rem;font-size:.65rem;background:#253140;color:var(--dim);border:1px solid #334252;width:18px;height:18px;display:flex;align-items:center;justify-content:center;border-radius:4px;cursor:pointer;transition:.25s;}
.tree li.has-children > .label{padding-left:1.15rem;}
.tree li.has-children > .toggle:hover{background:var(--accent);color:#fff;border-color:var(--accent);}
.label{font-weight:600;letter-spacing:.3px;font-size:.72rem;}
.meta{margin-top:.25rem;font-size:.63rem;color:var(--dim);letter-spacing:.3px;}
.badges{display:flex;flex-wrap:wrap;gap:.25rem;margin-top:.35rem;}
.badge{background:#253140;padding:.15rem .45rem;font-size:.55rem;border-radius:22px;letter-spacing:.5px;border:1px solid #2f4153;}
.node-path{font-size:.6rem;color:#6d7a87;margin-top:.25rem;}
.highlight{outline:2px solid #ffb347;outline-offset:2px;}

.status-bar{margin-top:1rem;font-size:.6rem;color:var(--dim);display:flex;gap:1rem;flex-wrap:wrap;}
.search-hit-count{font-weight:600;color:var(--accent);}

/* mini legend */
.legend{display:flex;flex-wrap:wrap;gap:.5rem;margin:1rem 0 0;}
.legend span{background:#253140;padding:.25rem .55rem;font-size:.6rem;border-radius:6px;border:1px solid #324354;}

@media (max-width:900px){
  .tree li{max-width:92%;width:100%;}
  .tree ul{padding-left:.9rem;}
}
</style>
</head>
<body>
<header>
  <h1>Slot Game AI Pipeline å¿ƒæ™ºåœ–</h1>
  <nav>
    <a href="index.html">å¹³å°é¦–é </a>
    <a href="slot_game_ai_agent_pipeline.html">Pipeline æ–‡ä»¶</a>
  </nav>
</header>
<main>
  <div class="tools-bar">
    <input id="search" placeholder="æœå°‹é—œéµå­— (ç¯€é» / KPI / ä»£ç†)..." />
    <button id="expandAll">å…¨éƒ¨å±•é–‹</button>
    <button id="collapseAll">å…¨éƒ¨æ”¶åˆ</button>
    <button id="clearSearch">æ¸…é™¤æœå°‹</button>
    <button id="exportJson">åŒ¯å‡º JSON</button>
    <button id="togglePixi">åˆ‡æ› PIXI è¦–åœ–</button>
  </div>
  <div id="mindmap-wrapper">
    <div id="mindmap" class="tree"></div>
  <div id="pixi-container" style="display:none; width:100%; height:70vh; position:relative; background:linear-gradient(145deg,#18232d,#0f181f 65%,#14242f); border:1px solid #2f3a46; border-radius:14px;">
      <div style="position:absolute; top:8px; right:10px; z-index:10; display:flex; gap:.4rem;">
        <button id="centerGraph" style="background:#253140; color:#b9c4cf; border:1px solid #324354; border-radius:6px; font-size:.6rem; padding:.3rem .6rem; cursor:pointer;">Center</button>
        <button id="fitGraph" style="background:#253140; color:#b9c4cf; border:1px solid #324354; border-radius:6px; font-size:.6rem; padding:.3rem .6rem; cursor:pointer;">Fit</button>
      </div>
    </div>
  </div>
  <div class="legend">
    <span>ğŸ“Œ ä¸»ç¯€é»</span><span>ğŸ§© ä»£ç†</span><span>ğŸ—‚ï¸ æµç¨‹éšæ®µ</span><span>ğŸ§ª æª¢æŸ¥é»</span><span>ğŸ“Š KPI</span><span>âš ï¸ é¢¨éšª/ç·©è§£</span><span>ğŸ’¡ æœªä¾†å¢å¼·</span>
  </div>
  <div class="status-bar">
    <div>ç¯€é»ç¸½æ•¸ï¼š<span id="nodeCount">--</span></div>
    <div>æœå°‹ç¬¦åˆï¼š<span id="hitCount" class="search-hit-count">0</span></div>
    <div>ç‰ˆæœ¬ï¼šv1.0 (ç”Ÿæˆæ–¼ 2025-10-03)</div>
  </div>
</main>
<!-- ä½¿ç”¨ PixiJS v7 åŒæ­¥ç‰ˆæœ¬ä»¥é¿å… v8 async init é€ æˆç©ºç™½ï¼›è‹¥éœ€å‡ç´šå¯å†èª¿æ•´ -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.3.3/pixi.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script>
// è³‡æ–™å®šç¾©ï¼šèˆ‡ä¸» pipeline æ–‡ä»¶å°é½Š
const DATA = {
  title: 'Slot Game AI Agent Pipeline',
  children: [
    {
      label: 'AI ä»£ç†', icon:'ğŸ§©', children: [
        { label:'ConceptArtAgent', meta:'ä¸»è¦–è¦º / é¢¨æ ¼æ¢ç´¢ â†’ concept_batch' },
        { label:'DesignParserAgent', meta:'è§£æä¼åŠƒ â†’ game_structure.json' },
        { label:'MathModelAgent', meta:'RTP æ¨¡æ“¬ â†’ math_model.json' },
        { label:'PSDAnalyzerAgent', meta:'PSD åœ–å±¤ â†’ art_spec.json' },
        { label:'AssetGenAgent', meta:'éœæ…‹ç´ æç”Ÿæˆ â†’ symbols/*.png' },
        { label:'PromptOptimizerAgent', meta:'å¤±æ•—æ¨£æœ¬å­¸ç¿’ â†’ æœ€ä½³åŒ– Prompt' },
        { label:'VFXSpecAgent', meta:'å‹•æ•ˆè¦æ ¼ â†’ vfx_spec.json' },
        { label:'VFXGenAgent', meta:'å‹•æ•ˆè¼¸å‡º â†’ frames / spine / Lottie' },
        { label:'EngineIntegrationAgent', meta:'æ•´åˆ â†’ manifest / slot_config.json' },
        { label:'SimulationAgent', meta:'è‡ªå‹•æ¸¬è©¦ â†’ validation_report' },
        { label:'AuditAgent', meta:'è¿½æº¯ â†’ decision_log.json' }
      ]
    },
    {
      label: '12 éšæ®µæµç¨‹', icon:'ğŸ—‚ï¸', children: (
        [ '1 Concept Art ç”Ÿæˆ','2 è¦–è¦ºå¯©æ ¸','3 ä¼åŠƒè§£æ','4 æ•¸å­¸æ¨¡å‹æ¨¡æ“¬','5 PSD è¦æ ¼ JSON','6 éœæ…‹ç”Ÿæˆ + Prompt','7 éœæ…‹å¯©æ ¸','8 å‹•æ•ˆè¦æ ¼','9 å‹•æ•ˆç”Ÿæˆ','10 å‹•æ•ˆå¯©æ ¸','11 æ•´åˆå¼•æ“','12 æ¸¬è©¦é©—è­‰' ]
      ).map(t=>({label:t}))
    },
    {
      label: 'å¥‘ç´„æª¢æŸ¥é»', icon:'ğŸ§ª', children: [
        'é¢¨æ ¼åˆ†æ•£åº¦','æ¬„ä½å®Œæ•´æ€§','RTP åå·®','å‘½ååˆè¦','è‰²å','ç‰¹æ•ˆæ™‚é–“é‡ç–Š','ç¼ºè³‡ç”¢æƒæ'
      ].map(l=>({label:l}))
    },
    {
      label: 'KPI æŒ‡æ¨™', icon:'ğŸ“Š', children: [
        'é¢¨æ ¼ä¸€è‡´ â‰¥0.85','RTP æ”¶æ–‚ â‰¤5','éœæ…‹äººå·¥å¯©æ ¸ <30%','å‹•æ•ˆç•°å¸¸å¹€ <1%','Prompt è¿­ä»£ â‰¤3','æ•´åˆéŒ¯èª¤ â‰¤1','RTP åå·® â‰¤0.5%','é€±æœŸç¸®çŸ­ â‰¥50%'
      ].map(l=>({label:l}))
    },
    {
      label: 'é¢¨éšªèˆ‡ç·©è§£', icon:'âš ï¸', children: [
        {label:'é¢¨æ ¼æ¼‚ç§»', meta:'åµŒå…¥æ¯”å° + è‰²ç¥¨é–å®š'},
        {label:'Prompt å†—é•·', meta:'Token æ¬Šé‡åˆ†æ'},
        {label:'PSD æ··äº‚', meta:'å‘½åæ­£è¦åŒ–'},
        {label:'RTP åå·®å¤§', meta:'å†æ¨¡æ“¬è¿­ä»£'},
        {label:'å‹•æ•ˆé–ƒçˆ', meta:'FrameDiff æª¢æ¸¬'},
        {label:'è³‡ç”¢ç¼ºæ¼', meta:'hash æƒæ'},
        {label:'è¿½æº¯å›°é›£', meta:'decision_log.json'}
      ]
    },
    {
      label: 'Prompt æ¨¡æ¿', icon:'ğŸ’¬', children:[
        {label:'éœæ…‹ç¬¦è™Ÿ Prompt', meta:'slot symbol of [å…ƒç´ ] ...'},
        {label:'å‹•æ…‹ç‰¹æ•ˆæ™‚é–“è»¸', meta:'charge/burst/fade JSON'},
        {label:'æ•¸å­¸æ¨¡å‹ç”Ÿæˆ', meta:'RTP simulate + adjust'}
      ]
    },
    {
      label: 'å°å…¥å„ªå…ˆé †åº', icon:'ğŸ§­', children:[
        '1 æ•¸å­¸/ä¼åŠƒè§£æ','2 PSD è¦æ ¼åŒ–','3 éœæ…‹ç”Ÿæˆ + å¯©æ ¸','4 å‹•æ…‹ç‰¹æ•ˆ','5 æ•´åˆèˆ‡é©—è­‰'
      ].map(l=>({label:l}))
    },
    {
      label: 'Audit ç´€éŒ„', icon:'ğŸ“‘', children:[
        {label:'decision_log.json ç¯„ä¾‹', meta:'timestamp/action/èª¿æ•´/æ ¸å‡†'}
      ]
    },
    {
      label: 'æœªä¾†å¢å¼·', icon:'ğŸ’¡', children:[
        'å·®ç•°è¦–è¦ºåŒ– Diff UI','å‹•æ•ˆåƒæ•¸ RL å„ªåŒ–','ç©å®¶è¡Œç‚ºå›é¥‹è¿­ä»£','Prompt Ensembling'
      ].map(l=>({label:l}))
    }
  ]
};

// ç”Ÿæˆæ¨¹ç‹€ç¯€é»
function buildNode(obj, depth=0, path=[]) {
  const node = document.createElement('li');
  const labelWrap = document.createElement('div');
  labelWrap.className = 'label';
  const fullLabel = (obj.icon? obj.icon+' ' : '') + obj.label;
  labelWrap.textContent = fullLabel;
  node.appendChild(labelWrap);
  if (obj.meta || obj.badges) {
    if (obj.meta){
      const m = document.createElement('div'); m.className='meta'; m.textContent = obj.meta; node.appendChild(m);
    }
    if (obj.badges){
      const b = document.createElement('div'); b.className='badges'; obj.badges.forEach(x=>{ const span=document.createElement('span'); span.className='badge'; span.textContent=x; b.appendChild(span); }); node.appendChild(b);
    }
  }
  const newPath = [...path, obj.label];
  const pathEl = document.createElement('div'); pathEl.className='node-path'; pathEl.textContent=newPath.join(' / '); node.appendChild(pathEl);

  if (obj.children && obj.children.length){
    node.classList.add('has-children');
    const toggle=document.createElement('div'); toggle.className='toggle';
    toggle.addEventListener('click',()=>{ node.classList.toggle('collapsed'); toggle.textContent = node.classList.contains('collapsed') ? '+' : 'âˆ’'; });
    node.insertBefore(toggle, labelWrap);
    const ul=document.createElement('ul');
    obj.children.forEach(ch=>{
      if (typeof ch==='string') ch={label:ch};
      ul.appendChild(buildNode(ch, depth+1, newPath));
    });
    node.appendChild(ul);
    // åˆå§‹åªå±•é–‹å‰äºŒå±¤ï¼šroot(depth 0) + ç¬¬ä¸€å±¤(depth 1) + ç¬¬äºŒå±¤(depth 2) å±•é–‹ï¼Œå…¶é¤˜ (depth>=3) æ”¶åˆ
    if (depth >= 3) {
      node.classList.add('collapsed');
      toggle.textContent = '+';
    } else {
      toggle.textContent = 'âˆ’';
    }
  }
  return node;
}

function render(){
  const rootEl = document.getElementById('mindmap');
  rootEl.innerHTML='';
  const topUL=document.createElement('ul');
  const rootNode = buildNode({label:DATA.title, icon:'ğŸ“Œ', children:DATA.children});
  topUL.appendChild(rootNode);
  rootEl.appendChild(topUL);
  updateCount();
}

function allNodes(){ return [...document.querySelectorAll('#mindmap li')]; }
function updateCount(){ document.getElementById('nodeCount').textContent = allNodes().length; }

// æœå°‹åŠŸèƒ½
const searchInput = document.getElementById('search');
searchInput.addEventListener('input', ()=> performSearch(searchInput.value.trim()));

function performSearch(q){
  const nodes = allNodes();
  nodes.forEach(n=> n.classList.remove('highlight'));
  if(!q){ document.getElementById('hitCount').textContent='0'; return; }
  const lower = q.toLowerCase();
  let hits=0;
  nodes.forEach(n=>{
    const text = n.textContent.toLowerCase();
    if (text.includes(lower)) {
      n.classList.add('highlight');
      // å±•é–‹æ‰€æœ‰çˆ¶å±¤
      let p=n.parentElement; while(p && p.id!=='mindmap'){ if(p.tagName==='LI') { p.classList.remove('collapsed'); const t=p.querySelector(':scope > .toggle'); if(t) t.textContent='âˆ’'; } p=p.parentElement; }
      hits++;
    }
  });
  document.getElementById('hitCount').textContent=hits;
}

// æ§åˆ¶æŒ‰éˆ•
function setAll(collapsed){
  allNodes().forEach(n=>{
    if(n.classList.contains('has-children')){
      n.classList.toggle('collapsed', collapsed);
      const t=n.querySelector(':scope > .toggle'); if(t) t.textContent = collapsed ? '+' : 'âˆ’';
    }
  });
}

document.getElementById('expandAll').onclick=()=>setAll(false);
 document.getElementById('collapseAll').onclick=()=>setAll(true);
 document.getElementById('clearSearch').onclick=()=>{ searchInput.value=''; performSearch(''); };
document.getElementById('exportJson').onclick=()=>{
  if(!DATA){ alert('è³‡æ–™å°šæœªè¼‰å…¥'); return; }
  const blob=new Blob([JSON.stringify(DATA,null,2)],{type:'application/json'});
  const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='pipeline_mindmap.json'; a.click(); URL.revokeObjectURL(a.href);
};

// åˆå§‹å…ˆä¸ renderï¼Œç­‰å…±äº« JSON è¼‰å…¥

// ================= PIXI.JS è¦–åœ– =================
// å°‡ DATA è½‰ç‚ºå¯æŠ˜ç–Šçš„æ¨¹ (åŠ ä¸Š collapsed å±¬æ€§)
function cloneData(obj){
  if (typeof obj === 'string') return { label: obj };
  return {
    label: obj.label,
    icon: obj.icon,
    meta: obj.meta,
    badges: obj.badges,
    collapsed: false,
    children: obj.children ? obj.children.map(cloneData) : []
  };
}
let PIXI_DATA_ROOT = null;
function initCollapsed(n, depth=0){ if(depth>=3) n.collapsed=true; else n.collapsed=false; if(n.children) n.children.forEach(c=> initCollapsed(c, depth+1)); }
function assignIds(n, path=[]){ n._id=[...path,n.label].join('>'); if(n.children) n.children.forEach(ch=> assignIds(ch,[...path,n.label])); }
function setupPixiData(){
  if(!DATA) return;
  PIXI_DATA_ROOT = { label: DATA.title, icon:'ğŸ“Œ', collapsed:false, children: DATA.children.map(cloneData) };
  initCollapsed(PIXI_DATA_ROOT,0);
  assignIds(PIXI_DATA_ROOT,[]);
  console.log('[PIXI-DEBUG] Data root children =', PIXI_DATA_ROOT.children.length);
  // è‹¥ PIXI å·²åˆå§‹åŒ–å‰‡é‡ç•«
  if(pixiInitialized) drawPixi();
}

// éŒ¯èª¤è¨Šæ¯è¦†è“‹å±¤
const pixiErrorOverlay = document.createElement('div');
pixiErrorOverlay.id = 'pixi-error-overlay';
pixiErrorOverlay.style.cssText='display:none;position:absolute;inset:0;z-index:20;backdrop-filter:blur(4px);background:rgba(15,20,28,.82);color:#ff7878;font:600 13px/1.5 \'Inter\',sans-serif;padding:22px;overflow:auto;border:1px solid #3a4654;border-radius:14px;';
pixiErrorOverlay.innerHTML='<div style="max-width:560px;margin:0 auto;text-align:center;"><h2 style="margin:0 0 12px;font-size:18px;letter-spacing:.5px;">âš ï¸ PIXI è¼‰å…¥å¤±æ•—</h2><p style="opacity:.85;margin:0 0 14px;">å¯èƒ½çš„åŸå› ï¼šCDN é˜»æ“‹ / å®Œæ•´æ€§ (SRI) é©—è­‰å¤±æ•— / ä¼æ¥­é˜²ç«ç‰†ã€‚å·²åœç”¨ Canvas è¦–åœ–ã€‚</p><button id="retryPixi" style="background:#253140;color:#c9d4df;border:1px solid #395067;padding:6px 14px;border-radius:8px;cursor:pointer;font-size:12px;">é‡æ–°å˜—è©¦è¼‰å…¥</button></div>';
document.addEventListener('DOMContentLoaded',()=>{
  const pixiContainer=document.getElementById('pixi-container');
  if(pixiContainer) pixiContainer.appendChild(pixiErrorOverlay);
  const retryBtn=document.getElementById('retryPixi');
  if(retryBtn) retryBtn.addEventListener('click',()=>{
    pixiErrorOverlay.style.display='none';
    dynamicLoadPixi(()=>{ console.log('[PIXI] retry load attempt'); if(window.PIXI){ initPixi(); } else { pixiError('ä»ç„¡æ³•è¼‰å…¥ PIXIã€‚'); } });
  });
});

let pixiInitialized = false;
let pixiApp, pixiStage, panContainer;
let nodeGraphics = []; // store {node,data,g,label,meta}
const NODE_STYLE = { baseRadius: 38, hGap: 160, vGap: 110, padX: 26, padY: 12 };
let cameraScale = 1; // ä¸ç¸®æ”¾å®¹å™¨ï¼Œæ‰‹å‹•è¨ˆç®—ä½ç½® (æ–‡å­—ä¿æŒæ¸…æ™°)
let panX = 0, panY = 0;
const SCALE_MIN = 0.3, SCALE_MAX = 2.8;
let layoutMode = 'radial'; // 'radial' å…¨æ–¹å‘å¿ƒæ™ºåœ– (å¯æ—¥å¾ŒåŠ å…¥å…¶ä»–æ¨¡å¼)
let edgesGraphics = null;
let lastVisibleNodes = [];
let draggingNode = null; // {node,g,startX,startY,origX,origY}
let savedPositions = {};
try { savedPositions = JSON.parse(localStorage.getItem('mindmapNodePositions')||'{}'); } catch(e){ savedPositions = {}; }

function savePositions(){
  const out = {...savedPositions};
  // åªå„²å­˜è¢«æ‹–æ›³é (æ¨™è¨˜ _manual) çš„ç¯€é»
  lastVisibleNodes.forEach(n=>{
    if(n._manual){ out[n._id] = { x: n._rawX, y: n._rawY }; }
  });
  localStorage.setItem('mindmapNodePositions', JSON.stringify(out));
}

function buildLayout(root){
  // è¨ˆç®—æ¯å€‹ç¯€é»å­æ¨¹å¯¬åº¦ (ä»¥è‘‰å­æ•¸ç‚ºå–®ä½)
  function dfsWidth(n){
    if(!n.children || n.children.length===0) { n._w = 1; return 1; }
    let sum = 0;
    n.children.forEach(c=>{ if(!c._removed) sum += dfsWidth(c); });
    n._w = Math.max(1,sum);
    return n._w;
  }
  dfsWidth(root);
  // æŒ‡å®šä½å€ (ä½¿ç”¨ top-downï¼Œæ°´å¹³æ ¹æ“šå­æ¨¹å¯¬åº¦ä¸­å¿ƒ)
  function dfsPos(n, depth, xStart){
    n.depth = depth;
    if(!n.children || n.children.length===0){
      n.xCenter = xStart + 0.5; // half unit
      return 1;
    }
    let cursor = xStart;
    n.children.forEach(c=>{
      const w = c._w;
      dfsPos(c, depth+1, cursor);
      cursor += w;
    });
    // center = average of children centers
    let min = Infinity, max = -Infinity;
    n.children.forEach(c=>{ if(c.xCenter<min) min=c.xCenter; if(c.xCenter>max) max=c.xCenter; });
    n.xCenter = (min+max)/2;
  }
  dfsPos(root, 0, 0);
}

function gatherVisible(root){
  const result = [];
  function walk(n){
    result.push(n);
    if(!n.collapsed && n.children){
      n.children.forEach(c=> walk(c));
    }
  }
  walk(root);
  return result;
}

function pixiError(msg){
  pixiErrorOverlay.style.display='block';
  if(msg) console.error('[PIXI ERROR]', msg);
}

function dynamicLoadPixi(cb){
  if(window.PIXI){ cb && cb(); return; }
  const alt = document.createElement('script');
  alt.src='https://unpkg.com/pixi.js@8/dist/pixi.min.js';
  alt.crossOrigin='anonymous';
  alt.onload=()=> cb && cb();
  alt.onerror=()=> { pixiError('CDN å‚™æ´è¼‰å…¥å¤±æ•—'); cb && cb(); };
  document.head.appendChild(alt);
}

async function initPixi(){
  if(pixiInitialized){ console.log('[PIXI-DEBUG] Already initialized'); return; }
  if(typeof PIXI === 'undefined'){ pixiError('PIXI ç‰©ä»¶ä¸å­˜åœ¨ (å¯èƒ½è¢«é˜»æ“‹)'); return; }
  const container = document.getElementById('pixi-container');
  try {
    // v8 ç›¸å®¹ï¼šè‹¥ Application.prototype.init å­˜åœ¨å‰‡æ¡ç”¨ async æµç¨‹
    if(PIXI.Application && PIXI.Application.prototype && PIXI.Application.prototype.init){
      console.log('[PIXI-DEBUG] Detected v8 style Application, using async init');
      pixiApp = new PIXI.Application();
      await pixiApp.init({ resizeTo: container, antialias:true, backgroundAlpha:0 });
    } else {
      // v7 åŒæ­¥
      pixiApp = new PIXI.Application({ resizeTo: container, antialias:true, backgroundAlpha:0 });
    }
  } catch(err){ pixiError('åˆå§‹åŒ–å¤±æ•—: '+ err.message); return; }
  container.appendChild(pixiApp.view);
  panContainer = new PIXI.Container();
  pixiApp.stage.addChild(panContainer);
  pixiStage = panContainer;
  enablePanZoom(container, panContainer);
  pixiInitialized = true;
  console.log('[PIXI-DEBUG] Init complete, drawing...');
  drawPixi();
}

// ========== Radial Layout Utilities ==========
function computeLeafCounts(n){
  if(!n.children || n.children.length===0){ n._leaf=1; return 1; }
  let sum=0; n.children.forEach(c=>{ sum += computeLeafCounts(c); }); n._leaf = Math.max(1,sum); return n._leaf;
}
function collectVisible(root){
  const out=[]; (function walk(n){ out.push(n); if(!n.collapsed && n.children) n.children.forEach(walk); })(root); return out;
}
function clamp(v,min,max){ return v<min?min: (v>max?max:v); }
function lightenColor(hex, factor){ // factor >1 è®Šäº®
  let r=(hex>>16)&255, g=(hex>>8)&255, b=hex&255;
  r = clamp(Math.round(r + (255-r)*factor),0,255);
  g = clamp(Math.round(g + (255-g)*factor),0,255);
  b = clamp(Math.round(b + (255-b)*factor),0,255);
  return (r<<16)|(g<<8)|b;
}
const SECTOR_PALETTE = [ '#4f8bff','#ff6f4f','#6dd96b','#ffcb3c','#c55bff','#38d5e7','#ff3fa4','#9cc94f','#ff8bd2','#52b3ff' ];

function assignAngles(root){
  computeLeafCounts(root);
  const children = root.children || [];
  const total = children.reduce((a,c)=>a + c._leaf,0) || 1;
  let cursor = -Math.PI/2; // start top
  children.forEach((c,i)=>{
    const span = (c._leaf/total) * Math.PI*2;
    assignAngleRange(c, cursor, cursor+span, 1, SECTOR_PALETTE[i % SECTOR_PALETTE.length]);
    cursor += span;
  });
  root._angle = 0; root._radius = 0; root._sectorColor = '#ffffff';
}
function assignAngleRange(n, a0, a1, depth, baseColor){
  n._a0=a0; n._a1=a1; n._angle = (a0+a1)/2; n._radiusDepth = depth; n._sectorColor = baseColor;
  if(!n.children || n.children.length===0) return;
  const total = n.children.reduce((s,c)=> s + c._leaf, 0) || 1;
  let cur=a0;
  n.children.forEach(c=>{
    const span = (c._leaf/total) * (a1-a0);
    assignAngleRange(c, cur, cur+span, depth+1, baseColor);
    cur += span;
  });
}

function drawPixi(){
  if(!pixiInitialized){ console.warn('[PIXI-DEBUG] drawPixi called before init'); return; }
  panContainer.removeChildren();
  nodeGraphics = [];
  const containerEl = document.getElementById('pixi-container');
  const W = containerEl.clientWidth;
  const H = containerEl.clientHeight;
  if(layoutMode === 'radial'){
    assignAngles(PIXI_DATA_ROOT);
    const visible = collectVisible(PIXI_DATA_ROOT);
    lastVisibleNodes = visible;
    // æ±‚æœ€å¤§æ·±åº¦ (visible)
    let maxDepth = 1; visible.forEach(n=>{ if(n._radiusDepth && n._radiusDepth>maxDepth) maxDepth = n._radiusDepth; });
    const margin = 110;
    const maxR = Math.min(W,H)/2 - margin;
    const rStep = maxR / Math.max(1, maxDepth);
    visible.forEach(n=>{
      const r = (n._radiusDepth||0) * rStep;
      n._rawX = Math.cos(n._angle || 0) * r;
      n._rawY = Math.sin(n._angle || 0) * r;
      n.depth = n._radiusDepth||0;
    });
    // ==== ç¯€é»å°ºå¯¸æ¸¬é‡ (ä¾›ç¢°æ’è¨ˆç®—) ====
    const measureCache = new Map();
    function measureNode(n){
      if(measureCache.has(n)) return measureCache.get(n);
      const mainFont = Math.max(11, 12*cameraScale*0.95);
      const label = new PIXI.Text(n.label,{fontSize:mainFont,fontWeight:'600'}); label.updateText();
      let metaW=0, metaH=0; if(n.meta){ const mf=Math.max(8,9*cameraScale*0.9); const metaT=new PIXI.Text(n.meta,{fontSize:mf}); metaT.updateText(); metaW=metaT.width; metaH=metaT.height+4; }
      const padX = NODE_STYLE.padX * (0.75 + (cameraScale-1)*0.22);
      const padY = NODE_STYLE.padY * (0.75 + (cameraScale-1)*0.22);
      const contentW = Math.max(label.width, metaW);
      const boxW = Math.max(130, contentW + padX*2);
      const boxH = label.height + metaH + padY*2;
      const dims={boxW,boxH}; measureCache.set(n,dims); return dims;
    }
    visible.forEach(n=>{ const d=measureNode(n); n._boxW=d.boxW; n._boxH=d.boxH; });

    // ==== åœ“ç’°æ’æ“ ï¼šå¤šè¿­ä»£åœ“å½¢æ‰“åŒ…é¿å…é‡ç–Š ====
    function resolveRing(depth){
      const group = visible.filter(n=> n.depth===depth);
      if(group.length<=1) return;
      const r = depth * rStep || 1;
      let baseExtra = 34;
      // å‹•æ…‹å¯¬åº¦å¹³å‡ï¼Œç‰¹å¯¬ç¯€é» spacing æ”¾å¤§
      const avgW = group.reduce((s,n)=> s + n._boxW, 0)/group.length;
      const WIDE_FACTOR = 1.35; // è¶…éå¹³å‡ 1.35 å€è¦–ç‚ºç‰¹å¯¬
      group.forEach(n=>{ const extra = (n._boxW> avgW*WIDE_FACTOR)? 28 : 0; n._half = (n._boxW + baseExtra + extra)/(2*r); });
      let required = group.reduce((s,n)=> s + n._half*2, 0);
      if(required > Math.PI*2){
        const scale = (Math.PI*2) / required; group.forEach(n=> n._half*=scale); required = Math.PI*2;
      }
      // è¿­ä»£ç›¸é„°ç¢°æ’åˆ†é›¢ï¼ˆåªå¾€å‰æ¨ï¼Œä¹‹å¾Œå†åšé¦–å°¾èˆ‡å›ç¸®å¹³è¡¡ï¼‰
      const MAX_ITER = 10;
      for(let iter=0; iter<MAX_ITER; iter++){
        let moved=false; group.sort((a,b)=> (a._angle||0) - (b._angle||0));
        // ç·šæ€§ forward åˆ†é›¢
        for(let i=0;i<group.length-1;i++){
          const A = group[i], B = group[i+1];
          const needed = A._half + B._half;
          const gap = (B._angle||0) - (A._angle||0);
          if(gap < needed){ const shift = needed - gap; for(let j=i+1;j<group.length;j++){ group[j]._angle += shift; } moved=true; }
        }
        // é¦–å°¾ wrap æª¢æŸ¥
        group.sort((a,b)=> (a._angle||0) - (b._angle||0));
        const first = group[0], last = group[group.length-1];
        const wrapGap = (first._angle||0) + Math.PI*2 - (last._angle||0);
        const wrapNeeded = first._half + last._half;
        if(wrapGap < wrapNeeded){
          const deficit = wrapNeeded - wrapGap;
          // å‡å‹»æ’é–‹ï¼šæŠŠæ‰€æœ‰ç¯€é»è§’åº¦åŠ ä¸Šç·šæ€§å¢é‡ï¼ˆä¸å½±éŸ¿ç›¸å°é †åºï¼‰
          const per = deficit / group.length;
          group.forEach((n,i)=>{ n._angle += per * i; });
          moved=true;
        }
        if(!moved) break;
      }
      // å›ç¸®èˆ‡ä¸­å¿ƒåŒ–ï¼šå°‡è§’åº¦å¹³ç§»ä½¿å¹³å‡è§’ â‰ˆ åŸå§‹å¹³å‡ (é¿å…æ¼‚ç§»éå¤š)
      const mean = group.reduce((s,n)=> s + (n._angle||0),0)/group.length;
      const targetMean = group.reduce((s,n)=> s + (n._a0 + n._a1)/2,0)/group.length; // åŸå§‹åˆ†é…çš„å¹³å‡è»¸
      const delta = targetMean - mean;
      group.forEach(n=> n._angle += delta);
      // åˆ¤æ–·æ˜¯å¦éœ€è¦é›™å±¤ (å¯†åº¦/æ•¸é‡æº–å‰‡)
      const RING_NODE_SPLIT_THRESHOLD = 18;
      const avgHalf = group.reduce((s,n)=> s + n._half,0)/group.length;
      const needSplit = group.length > RING_NODE_SPLIT_THRESHOLD || avgHalf < 0.025;
      if(needSplit){
        group.sort((a,b)=> b._boxW - a._boxW);
        const outer=[], inner=[]; group.forEach((n,i)=> (i%2===0?outer:inner).push(n));
        const outShift = rStep*0.55, inShift = -rStep*0.38; const minRadius = r*0.45;
        inner.forEach(n=>{ n._ringShift = Math.max(inShift, minRadius - r); });
        outer.forEach(n=>{ n._ringShift = outShift; });
      } else { group.forEach(n=> n._ringShift=0); }
      // æ­£è¦åŒ–è§’åº¦ç¯„åœ
      group.forEach(n=>{ while(n._angle > Math.PI) n._angle -= Math.PI*2; while(n._angle <= -Math.PI) n._angle += Math.PI*2; });
    }
    for(let d=1; d<=maxDepth; d++) resolveRing(d);

    // å¯é¸ï¼šä¸­å¿ƒå†å¹³è¡¡ (ç¶­æŒåŸå§‹æ‰‡å€ä¸­ç·š) â€“ æ­¤è™•ç•¥éä»¥ä¿è­‰æ’æ“ çµæœ
    // é‡æ–°ä¾èª¿æ•´å¾Œè§’åº¦è¨ˆç®—åº§æ¨™
    visible.forEach(n=>{
      const baseR = (n.depth||0) * rStep;
      const r = baseR + (n._ringShift || 0);
      n._rawX = Math.cos(n._angle||0) * r;
      n._rawY = Math.sin(n._angle||0) * r;
      // å¥—ç”¨ä½¿ç”¨è€…æ‰‹å‹•ä½ç½®è¦†è“‹ (è‹¥å­˜åœ¨å„²å­˜)
      if(savedPositions[n._id]){
        n._rawX = savedPositions[n._id].x;
        n._rawY = savedPositions[n._id].y;
        n._manual = true;
      }
    });
    // é‚Šç·š (å…ˆå»ºç«‹ï¼Œä¹‹å¾Œæ‹–æ›³å¯é‡ç¹ª)
    edgesGraphics = new PIXI.Graphics(); panContainer.addChild(edgesGraphics);
    function drawEdges(){
      if(!edgesGraphics) return;
      edgesGraphics.clear();
      lastVisibleNodes.forEach(n=>{
        if(!n.collapsed && n.children){
          n.children.forEach(c=>{
            if(!lastVisibleNodes.includes(c)) return;
            edgesGraphics.lineStyle(2,0x324250,0.9);
            const sx = (n._rawX * cameraScale + panX);
            const sy = (n._rawY * cameraScale + panY);
            const tx = (c._rawX * cameraScale + panX);
            const ty = (c._rawY * cameraScale + panY);
            const midR = Math.hypot(sx-tx, sy-ty)/2;
            const angleMid = Math.atan2( (sy+ty)/2 - panY, (sx+tx)/2 - panX );
            const ctrlDist = midR * 0.55;
            const cx = ((sx+tx)/2) + Math.cos(angleMid)*ctrlDist;
            const cy = ((sy+ty)/2) + Math.sin(angleMid)*ctrlDist;
            edgesGraphics.moveTo(sx,sy);
            edgesGraphics.quadraticCurveTo(cx,cy,tx,ty);
          });
        }
      });
    }
    // ç¯€é»ç¹ªè£½
    visible.forEach(n=>{
      const g = new PIXI.Container(); g.eventMode='static'; g.cursor='pointer';
      const depth = n.depth||0;
      const baseColorHex = PIXI.utils.string2hex(n._sectorColor || '#4f8bff');
      const lightenFactor = Math.min(0.6, depth*0.07); // é€å±¤è®Šäº®
      const fillHex = lightenColor(baseColorHex, lightenFactor);
      const strokeHex = baseColorHex;
      const mainFontSize = Math.max(11, 12*cameraScale*0.95);
      const label = new PIXI.Text(n.label,{fontSize: mainFontSize, fill:'#f2f6fb', fontWeight:'600'}); label.updateText();
      let metaObj=null; if(n.meta){ const mf = Math.max(8, 9*cameraScale*0.9); metaObj=new PIXI.Text(n.meta,{fontSize:mf, fill:'#c9d6e2'}); metaObj.updateText(); }
      const lineHeight = label.height; const metaHeight = metaObj? metaObj.height + 4 : 0;
      const contentW = Math.max(label.width, metaObj? metaObj.width:0);
      const padX = NODE_STYLE.padX * (0.75 + (cameraScale-1)*0.22);
      const padY = NODE_STYLE.padY * (0.75 + (cameraScale-1)*0.22);
      const boxW = Math.max(130, contentW + padX*2);
      const boxH = lineHeight + metaHeight + padY*2;
      const radius = 16 * (0.8 + (cameraScale-1)*0.18);
      const box = new PIXI.Graphics();
      box.beginFill(fillHex,0.92).lineStyle(2, strokeHex, 0.95).drawRoundedRect(-boxW/2,-boxH/2,boxW,boxH,radius).endFill();
      try { const ds = new PIXI.filters.DropShadowFilter({color:0x000000,alpha:0.45,blur:4,distance:3,rotation:60}); box.filters=[ds]; } catch(e){}
      g.addChild(box);
      label.anchor.set(.5,0); label.x=0; label.y = -boxH/2 + padY; g.addChild(label);
      if(metaObj){ metaObj.anchor.set(.5,0); metaObj.x=0; metaObj.y=label.y+lineHeight+4; g.addChild(metaObj); }
      if(n.children && n.children.length){
        const sign = new PIXI.Text(n.collapsed?'+':'âˆ’',{fontSize: Math.max(11, 12*cameraScale), fill:'#ffffff'}); sign.anchor.set(.5); sign.x = boxW/2 - 14; sign.y = -boxH/2 + 14; g.addChild(sign); g._sign=sign;
      }
      g.x = n._rawX * cameraScale + panX;
      g.y = n._rawY * cameraScale + panY;
      g._dims = {boxW, boxH, radius, sectorColor: strokeHex};
      // é»æ“Š + æ‹–æ›³é‚è¼¯ï¼šæŒ‰ä½æ‹–æ›³ï¼Œé»æ“Š(å¿«é€Ÿ)åˆ‡æ›æ”¶åˆ
      let downTime=0, moved=false;
      g.on('pointerdown', e=>{
        downTime=Date.now(); moved=false; e.stopPropagation();
        draggingNode = { node:n, g, startX:e.globalX, startY:e.globalY, origX:n._rawX, origY:n._rawY };
      });
      g.on('pointerup', e=>{
        e.stopPropagation();
        const dt = Date.now()-downTime;
        if(!moved && dt < 250){ // è¦–ç‚ºé»æ“Šåˆ‡æ›
          if(n.children && n.children.length){ n.collapsed=!n.collapsed; drawPixi(); }
        } else {
          // æ‹–æ›³çµæŸï¼Œä¿å­˜ä½ç½®
          n._manual = true; savedPositions[n._id] = {x:n._rawX, y:n._rawY}; savePositions();
        }
        draggingNode=null;
      });
      g.on('pointerupoutside', ()=>{ if(draggingNode && draggingNode.node===n){ n._manual=true; savedPositions[n._id]={x:n._rawX,y:n._rawY}; savePositions(); draggingNode=null; } });
      panContainer.addChild(g);
      nodeGraphics.push({node:n,g,box});
    });
    // å…¨éƒ¨ç¯€é»å»ºç«‹å¾Œå†ç•«é‚Š
    panContainer.setChildIndex(edgesGraphics, 0);
    (function initialEdge(){ drawEdges(); })();

    // å…¨åŸŸ pointermove for æ‹–æ›³
    pixiApp.stage.eventMode = 'passive';
    pixiApp.stage.on('pointermove', (e)=>{
      if(!draggingNode) return;
      const dx = (e.globalX - draggingNode.startX)/cameraScale;
      const dy = (e.globalY - draggingNode.startY)/cameraScale;
      draggingNode.node._rawX = draggingNode.origX + dx;
      draggingNode.node._rawY = draggingNode.origY + dy;
      draggingNode.g.x = draggingNode.node._rawX * cameraScale + panX;
      draggingNode.g.y = draggingNode.node._rawY * cameraScale + panY;
      draggingNode.node._manual = true;
      moved = true;
      // é‡ç¹ªé‚Š
      if(edgesGraphics){
        edgesGraphics.clear();
        lastVisibleNodes.forEach(n=>{
          if(!n.collapsed && n.children){
            n.children.forEach(c=>{
              if(!lastVisibleNodes.includes(c)) return;
              edgesGraphics.lineStyle(2,0x324250,0.9);
              const sx = (n._rawX * cameraScale + panX);
              const sy = (n._rawY * cameraScale + panY);
              const tx = (c._rawX * cameraScale + panX);
              const ty = (c._rawY * cameraScale + panY);
              const midR = Math.hypot(sx-tx, sy-ty)/2;
              const angleMid = Math.atan2( (sy+ty)/2 - panY, (sx+tx)/2 - panX );
              const ctrlDist = midR * 0.55;
              const cx = ((sx+tx)/2) + Math.cos(angleMid)*ctrlDist;
              const cy = ((sy+ty)/2) + Math.sin(angleMid)*ctrlDist;
              edgesGraphics.moveTo(sx,sy);
              edgesGraphics.quadraticCurveTo(cx,cy,tx,ty);
            });
          }
        });
      }
    });
  } else {
    // ä¿ç•™ï¼ˆæœªä¾†å¯æ“´å……å…¶ä»–æ¨¡å¼ï¼‰
  }
}

function enablePanZoom(dom){
  let dragging=false, lastX=0, lastY=0;
  dom.addEventListener('pointerdown', e=>{ dragging=true; lastX=e.clientX; lastY=e.clientY; });
  window.addEventListener('pointerup', ()=> dragging=false);
  window.addEventListener('pointermove', e=>{ if(!dragging) return; panX += (e.clientX - lastX); panY += (e.clientY - lastY); lastX=e.clientX; lastY=e.clientY; drawPixi(); });
  dom.addEventListener('wheel', e=>{ e.preventDefault(); const mouseX=e.offsetX, mouseY=e.offsetY; const beforeX = (mouseX - panX)/cameraScale; const beforeY = (mouseY - panY)/cameraScale; const factor = (e.deltaY < 0)? 1.1 : 0.9; cameraScale = Math.min(SCALE_MAX, Math.max(SCALE_MIN, cameraScale*factor)); panX = mouseX - beforeX*cameraScale; panY = mouseY - beforeY*cameraScale; drawPixi(); }, {passive:false});
}

function autoFitIfNeeded(){
  const dom = document.getElementById('pixi-container');
  if(layoutMode==='radial'){
    assignAngles(PIXI_DATA_ROOT);
    const visible = collectVisible(PIXI_DATA_ROOT);
    let maxDepth=1; visible.forEach(n=>{ if(n._radiusDepth && n._radiusDepth>maxDepth) maxDepth=n._radiusDepth; });
    const margin=120; const maxR = Math.min(dom.clientWidth, dom.clientHeight)/2 - margin;
    cameraScale = 1; // åŠå¾‘å·²ä¾å®¹å™¨è¨ˆç®—ï¼Œä¸éœ€é¡å¤–ç¸®æ”¾ (ä½¿ç”¨ pan/zoom å¾Œæ‰è®Š)
    panX = dom.clientWidth/2; panY = dom.clientHeight/2; // root ç½®ä¸­
    drawPixi();
  } else {
    // fallback ribbon layout (unused currently)
    buildLayout(PIXI_DATA_ROOT);
    const rootWUnits = PIXI_DATA_ROOT._w || 1;
    const tentativeGap = Math.min(240, Math.max(90, (dom.clientWidth - 260) / rootWUnits));
    NODE_STYLE.hGap = tentativeGap;
    const totalPixelWidth = rootWUnits * NODE_STYLE.hGap;
    cameraScale = Math.min(1.4, Math.max(0.6, (dom.clientWidth - 200)/ totalPixelWidth));
    panX = (dom.clientWidth - totalPixelWidth * cameraScale)/2;
    panY = 40;
    drawPixi();
  }
}

// æœå°‹åŒæ­¥åˆ° PIXI (é«˜äº®æé‚Š)
function highlightPixiMatches(q){
  if(!pixiInitialized) return;
  const lower = q.toLowerCase();
  nodeGraphics.forEach(({node,g,box})=>{
    if(!box || !g._dims) return; const {boxW, boxH, radius, sectorColor} = g._dims;
    const hit = q && (node.label.toLowerCase().includes(lower) || (node.meta && node.meta.toLowerCase().includes(lower)));
    const baseColor = sectorColor || 0x4f8bff;
    box.clear();
    const strokeW = hit?4:2;
    // hit æ™‚åŠ æ·±å¡«è‰²
    const fillCol = hit? 0x142a37 : 0x1d2b35;
    box.beginFill(fillCol, 0.96).lineStyle(strokeW, baseColor, 0.98).drawRoundedRect(-boxW/2,-boxH/2,boxW,boxH,radius).endFill();
    if(g._sign) g._sign.text = node.collapsed?'+':'âˆ’';
  });
}

// äº‹ä»¶æ›é‰¤æ•´åˆ
document.getElementById('togglePixi').addEventListener('click', ()=>{
  const domTree = document.getElementById('mindmap');
  const pixiDom = document.getElementById('pixi-container');
  const showingPixi = pixiDom.style.display !== 'none';
  if(showingPixi){
    pixiDom.style.display='none';
    domTree.style.display='block';
    document.getElementById('togglePixi').textContent='åˆ‡æ› PIXI è¦–åœ–';
  } else {
    domTree.style.display='none';
    pixiDom.style.display='block';
    if(!window.PIXI){
      console.log('[PIXI-DEBUG] global PIXI missing, attempting dynamic load');
      dynamicLoadPixi(()=>{ if(window.PIXI){ initPixi(); } else { pixiError('ä»æœªå–å¾— PIXI å…¨åŸŸç‰©ä»¶'); } });
    } else { initPixi(); }
    document.getElementById('togglePixi').textContent='åˆ‡æ› DOM è¦–åœ–';
  }
});

document.getElementById('centerGraph').addEventListener('click', ()=> autoFitIfNeeded());
document.getElementById('fitGraph').addEventListener('click', ()=> autoFitIfNeeded());

// Hook existing search
const origPerformSearch = performSearch;
performSearch = function(q){
  origPerformSearch(q);
  highlightPixiMatches(q);
};

// åœ¨å±•é–‹/æ”¶åˆå…¨éƒ¨æ™‚é‡æ–°ç¹ªè£½ PIXI
const origSetAll = setAll;
setAll = function(collapsed){
  origSetAll(collapsed);
  // ä¹ŸåŒæ­¥æ›´æ–° PIXI_DATA_ROOT (å…¨éƒ¨æŠ˜ç–Šæˆ–å±•é–‹)
  function sync(n){ n.collapsed = collapsed; n.children && n.children.forEach(sync); }
  sync(PIXI_DATA_ROOT);
  drawPixi();
};

// åˆå§‹ä¸è¼‰å…¥ PIXIï¼Œä½¿ç”¨è€…åˆ‡æ›æ™‚å†è¼‰å…¥
console.log('[PIXI] Ready (v7 sync preferred; v8 async guarded).');
// å‹•æ…‹è¼‰å…¥å…±äº« JSONï¼ˆèˆ‡ G6 ç‰ˆæœ¬å…±ç”¨ï¼‰
async function loadSharedData(){
  // å¤šé‡å€™é¸è·¯å¾‘ï¼šå› ç‚ºä½¿ç”¨è€…å¯èƒ½åœ¨ä¸åŒå·¥ä½œç›®éŒ„å•Ÿå‹• http server
  const candidates = [
    '../../../../data/pipeline_mindmap.json', // å‡è¨­ç«™é»æ ¹åœ¨å°ˆæ¡ˆæ ¹ç›®éŒ„ (æ­£ç¢ºå±¤ç´š)
    '../../../data/pipeline_mindmap.json',    // å°‘ä¸€å±¤ (å¸¸è¦‹èª¤å·®)
    '../../data/pipeline_mindmap.json',
    '../data/pipeline_mindmap.json',
    '/data/pipeline_mindmap.json',            // çµ•å°è·¯å¾‘ (è‹¥ä¼ºæœå™¨ root=å°ˆæ¡ˆ root)
    'data/pipeline_mindmap.json'              // è‹¥æ–¼ frontend ä¸‹æœ‰ data å‰¯æœ¬
  ];
  let lastError=null;
  for(const url of candidates){
    try {
      const resp = await fetch(url, {cache:'no-cache'});
      if(!resp.ok) throw new Error('HTTP '+resp.status);
      const json = await resp.json();
      DATA = json;
      console.log('[DATA] loaded from', url);
      setupPixiData();
      render();
      return;
    } catch(err){
      lastError = err;
      console.warn('[DATA] failed', url, err.message);
    }
  }
  const rootEl=document.getElementById('mindmap');
  if(rootEl){
    rootEl.innerHTML = `
      <div style="padding:14px;color:#ff6b6b;font-size:12px;line-height:1.5;">
        ç„¡æ³•è¼‰å…¥å…±äº«è³‡æ–™ï¼š<br>
        å˜—è©¦è·¯å¾‘ï¼š<code>${candidates.join('</code>, <code>')}</code><br>
        æœ€å¾ŒéŒ¯èª¤ï¼š${lastError? lastError.message : 'æœªçŸ¥'}<br>
        å»ºè­°ï¼šè«‹å¾å°ˆæ¡ˆæ ¹ç›®éŒ„å•Ÿå‹•ä¼ºæœå™¨ (ä¾‹ï¼š<code>python -m http.server 3000</code>) æˆ–åœ¨æœ¬ç›®éŒ„å»ºç«‹ <code>data/pipeline_mindmap.json</code> å‰¯æœ¬ã€‚
      </div>`;
  }
}
loadSharedData();
</script>
</body>
</html>